# Product Data Source 2 Integration - MallConnect

This document outlines the second product data source integration for MallConnect PWA, providing additional product data endpoints and expanded search capabilities.

## 🗄️ Database Schema - Source 2

### Product Tables Structure (Identical Schema)

The second data source uses the same optimized schema structure for consistency and unified search capabilities:

#### `product_search` Table - Source 2
```sql
CREATE TABLE public.product_search (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  product_id uuid NOT NULL DEFAULT gen_random_uuid(),
  embeddings public.vector NOT NULL,
  text text NULL,
  price numeric NULL,
  brand character varying NULL,
  gender character varying NULL,
  tag1 character varying NULL,
  tag2 character varying NULL,
  refined_text text NULL,
  fts tsvector GENERATED ALWAYS AS (to_tsvector('english'::regconfig, refined_text)) STORED NULL,
  CONSTRAINT products_search_pkey PRIMARY KEY (id, product_id)
) TABLESPACE pg_default;

-- Full-text search index
CREATE INDEX IF NOT EXISTS refined_text_fts_idx ON public.product_search USING gin (fts) TABLESPACE pg_default;
```

## 🔌 Supabase Connection - Source 2

### Environment Configuration
```env
# Product Source 2 - Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL_SOURCE2=https://cuoejzgwnlrceypuxsgr.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY_SOURCE2=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN1b2Vqemd3bmxyY2V5cHV4c2dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjMzMDM5MjAsImV4cCI6MjAzODg3OTkyMH0.8RjR6QMdGrTM00VD2EhOfylmF6eq3cdUtyHpW5sqWNY
```

### Connection Setup - Dual Source
```javascript
import { createClient } from '@supabase/supabase-js'

// Source 1 Connection
const supabaseUrl1 = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseKey1 = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
export const supabaseSource1 = createClient(supabaseUrl1, supabaseKey1)

// Source 2 Connection
const supabaseUrl2 = process.env.NEXT_PUBLIC_SUPABASE_URL_SOURCE2
const supabaseKey2 = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY_SOURCE2
export const supabaseSource2 = createClient(supabaseUrl2, supabaseKey2)
```

## 🔍 Multi-Source Search Implementation

### 1. Unified Search Across Both Sources
```javascript
const searchAllSources = async (query, filters = {}) => {
  const searchPromises = [
    searchSource1(query, filters),
    searchSource2(query, filters)
  ]

  try {
    const results = await Promise.allSettled(searchPromises)
    
    const combinedResults = []
    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value.data) {
        combinedResults.push(...result.value.data.map(item => ({
          ...item,
          source: index + 1,
          source_name: index === 0 ? 'Primary' : 'Secondary'
        })))
      }
    })

    // Sort by relevance/price
    return combinedResults.sort((a, b) => {
      if (filters.sortBy === 'price') {
        return a.price - b.price
      }
      return 0 // Default sorting
    })
  } catch (error) {
    console.error('Multi-source search error:', error)
    return []
  }
}

const searchSource1 = async (query, filters) => {
  return await supabaseSource1
    .from('product_search')
    .select('*')
    .textSearch('fts', query)
    .limit(20)
}

const searchSource2 = async (query, filters) => {
  return await supabaseSource2
    .from('product_search')
    .select('*')
    .textSearch('fts', query)
    .limit(20)
}
```

### 2. Source-Specific Search
```javascript
const searchSpecificSource = async (sourceNumber, query, filters = {}) => {
  const supabase = sourceNumber === 1 ? supabaseSource1 : supabaseSource2
  
  let queryBuilder = supabase
    .from('product_search')
    .select('*')

  if (query) {
    queryBuilder = queryBuilder.textSearch('fts', query)
  }

  // Apply filters
  if (filters.brand) {
    queryBuilder = queryBuilder.eq('brand', filters.brand)
  }
  
  if (filters.minPrice) {
    queryBuilder = queryBuilder.gte('price', filters.minPrice)
  }
  
  if (filters.maxPrice) {
    queryBuilder = queryBuilder.lte('price', filters.maxPrice)
  }

  if (filters.gender) {
    queryBuilder = queryBuilder.eq('gender', filters.gender)
  }

  const { data, error } = await queryBuilder.limit(20)
  
  return { 
    data: data?.map(item => ({ ...item, source: sourceNumber })), 
    error 
  }
}
```

### 3. Price Comparison Across Sources
```javascript
const comparePricesAcrossSources = async (productQuery) => {
  const [source1Results, source2Results] = await Promise.all([
    searchSource1(productQuery, {}),
    searchSource2(productQuery, {})
  ])

  const priceComparison = []

  // Combine and compare similar products
  const allProducts = [
    ...(source1Results.data || []).map(p => ({ ...p, source: 1 })),
    ...(source2Results.data || []).map(p => ({ ...p, source: 2 }))
  ]

  // Group by similar products (by brand + similar text)
  const productGroups = {}
  allProducts.forEach(product => {
    const key = `${product.brand}_${product.text?.substring(0, 20)}`
    if (!productGroups[key]) {
      productGroups[key] = []
    }
    productGroups[key].push(product)
  })

  // Find best prices for each product group
  Object.entries(productGroups).forEach(([key, products]) => {
    if (products.length > 1) {
      const sortedByPrice = products.sort((a, b) => a.price - b.price)
      priceComparison.push({
        product_name: products[0].text,
        brand: products[0].brand,
        best_price: sortedByPrice[0].price,
        best_source: sortedByPrice[0].source,
        price_difference: sortedByPrice[sortedByPrice.length - 1].price - sortedByPrice[0].price,
        all_options: sortedByPrice
      })
    }
  })

  return priceComparison
}
```

## 🚀 Advanced Multi-Source Features

### 1. Source Health Monitoring
```javascript
const checkSourceHealth = async () => {
  const healthChecks = await Promise.allSettled([
    supabaseSource1.from('product_search').select('count', { count: 'exact', head: true }),
    supabaseSource2.from('product_search').select('count', { count: 'exact', head: true })
  ])

  return {
    source1: {
      status: healthChecks[0].status === 'fulfilled' ? 'healthy' : 'error',
      count: healthChecks[0].value?.count || 0,
      error: healthChecks[0].reason
    },
    source2: {
      status: healthChecks[1].status === 'fulfilled' ? 'healthy' : 'error',
      count: healthChecks[1].value?.count || 0,
      error: healthChecks[1].reason
    }
  }
}
```

### 2. Fallback Strategy
```javascript
const searchWithFallback = async (query, filters = {}) => {
  try {
    // Try primary source first
    const primaryResults = await searchSource1(query, filters)
    
    if (primaryResults.data && primaryResults.data.length > 0) {
      return {
        data: primaryResults.data.map(item => ({ ...item, source: 1 })),
        source_used: 'primary'
      }
    }
    
    // Fallback to secondary source
    console.log('Falling back to secondary source')
    const secondaryResults = await searchSource2(query, filters)
    
    return {
      data: secondaryResults.data?.map(item => ({ ...item, source: 2 })) || [],
      source_used: 'secondary'
    }
    
  } catch (error) {
    console.error('Search fallback failed:', error)
    return { data: [], source_used: 'none', error }
  }
}
```

### 3. Data Synchronization Check
```javascript
const checkDataConsistency = async (sampleSize = 10) => {
  const [sample1, sample2] = await Promise.all([
    supabaseSource1.from('product_search').select('*').limit(sampleSize),
    supabaseSource2.from('product_search').select('*').limit(sampleSize)
  ])

  const consistency = {
    source1_count: sample1.data?.length || 0,
    source2_count: sample2.data?.length || 0,
    common_brands: [],
    unique_to_source1: [],
    unique_to_source2: []
  }

  if (sample1.data && sample2.data) {
    const brands1 = new Set(sample1.data.map(p => p.brand))
    const brands2 = new Set(sample2.data.map(p => p.brand))
    
    consistency.common_brands = [...brands1].filter(brand => brands2.has(brand))
    consistency.unique_to_source1 = [...brands1].filter(brand => !brands2.has(brand))
    consistency.unique_to_source2 = [...brands2].filter(brand => !brands1.has(brand))
  }

  return consistency
}
```

## 📊 Multi-Source Analytics

### Search Performance Tracking
```javascript
const trackSearchPerformance = async (query, filters = {}) => {
  const startTime = Date.now()
  
  const [source1Time, source2Time] = await Promise.all([
    measureSearchTime(supabaseSource1, query, filters),
    measureSearchTime(supabaseSource2, query, filters)
  ])
  
  const totalTime = Date.now() - startTime
  
  return {
    total_time: totalTime,
    source1_time: source1Time,
    source2_time: source2Time,
    faster_source: source1Time < source2Time ? 1 : 2
  }
}

const measureSearchTime = async (supabase, query, filters) => {
  const start = Date.now()
  await supabase.from('product_search').select('*').textSearch('fts', query).limit(1)
  return Date.now() - start
}
```

## 🔄 Data Management Strategy

### 1. Unified Product Aggregation
```javascript
const aggregateProductData = async (query) => {
  const results = await searchAllSources(query)
  
  // Remove duplicates based on similar products
  const uniqueProducts = []
  const seenProducts = new Set()
  
  results.forEach(product => {
    const productKey = `${product.brand}_${product.text?.toLowerCase().replace(/\s+/g, '_')}`
    
    if (!seenProducts.has(productKey)) {
      seenProducts.add(productKey)
      uniqueProducts.push(product)
    } else {
      // Update existing product if this one has better price
      const existingIndex = uniqueProducts.findIndex(p => 
        `${p.brand}_${p.text?.toLowerCase().replace(/\s+/g, '_')}` === productKey
      )
      
      if (existingIndex !== -1 && product.price < uniqueProducts[existingIndex].price) {
        uniqueProducts[existingIndex] = product
      }
    }
  })
  
  return uniqueProducts
}
```

### 2. Source Priority Configuration
```javascript
const SOURCE_PRIORITY = {
  1: { weight: 0.6, name: 'Primary' },
  2: { weight: 0.4, name: 'Secondary' }
}

const applySourcePriority = (results) => {
  return results.map(product => ({
    ...product,
    priority_score: SOURCE_PRIORITY[product.source]?.weight || 0.1,
    source_name: SOURCE_PRIORITY[product.source]?.name || 'Unknown'
  })).sort((a, b) => b.priority_score - a.priority_score)
}
```

## 🔮 Next Steps

1. **Load Balancing**: Implement intelligent load balancing between sources
2. **Caching Strategy**: Cache results from both sources with TTL
3. **Data Quality Monitoring**: Track data quality metrics across sources
4. **Automated Failover**: Implement automatic failover mechanisms
5. **Performance Optimization**: Optimize queries for both sources
6. **Data Deduplication**: Advanced algorithms for removing duplicate products

## 📝 Configuration Summary

### Environment Variables Required
```env
# Source 1
NEXT_PUBLIC_SUPABASE_URL=https://bndbyszujcbocpltxfah.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Source 2
NEXT_PUBLIC_SUPABASE_URL_SOURCE2=https://cuoejzgwnlrceypuxsgr.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY_SOURCE2=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Database Schema Status
- ✅ Both sources use identical `product_search` table structure
- ✅ Vector embeddings support for semantic search
- ✅ Full-text search with GIN indexing
- ✅ Structured filtering capabilities

---

**Status**: Dual-source integration ready
**Capability**: Unified search across multiple product databases
**Performance**: Optimized with fallback and load balancing strategies
