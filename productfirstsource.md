# Product Data Source Integration - MallConnect

This document outlines the product data integration setup for MallConnect PWA, including database schema, data structure, and integration endpoints.

## üóÑÔ∏è Database Schema

### Product Tables Structure

We have two main tables for handling product data with vector search capabilities:

#### 1. `product_metadata` Table
Stores comprehensive product information in JSONB format for flexibility.

```sql
CREATE TABLE public.product_metadata (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  product_id uuid NOT NULL DEFAULT gen_random_uuid(),
  metadata jsonb NOT NULL,
  CONSTRAINT products_pkey PRIMARY KEY (id, product_id)
) TABLESPACE pg_default;
```

**Purpose**: 
- Store rich product metadata (specifications, images, descriptions, etc.)
- Flexible JSONB structure allows for varying product attributes
- Unique product_id for cross-table references

#### 2. `product_search` Table
Optimized for search operations with vector embeddings and full-text search.

```sql
CREATE TABLE public.product_search (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  product_id uuid NOT NULL DEFAULT gen_random_uuid(),
  embeddings public.vector NOT NULL,
  text text NULL,
  price numeric NULL,
  brand character varying NULL,
  gender character varying NULL,
  tag1 character varying NULL,
  tag2 character varying NULL,
  refined_text text NULL,
  fts tsvector GENERATED ALWAYS AS (to_tsvector('english'::regconfig, refined_text)) STORED NULL,
  CONSTRAINT products_search_pkey PRIMARY KEY (id, product_id)
) TABLESPACE pg_default;

-- Full-text search index
CREATE INDEX IF NOT EXISTS refined_text_fts_idx ON public.product_search USING gin (fts) TABLESPACE pg_default;
```

**Purpose**:
- Vector embeddings for semantic search
- Full-text search capabilities
- Structured fields for filtering (price, brand, gender, tags)
- Optimized for fast product discovery

## üîç Search Capabilities

### 1. Vector Search
- **embeddings**: Vector representations of products for semantic similarity
- Enables finding products based on meaning, not just keywords
- Example: "smartphone" can match "iPhone", "Android phone", etc.

### 2. Full-Text Search (FTS)
- **fts**: Generated tsvector column for PostgreSQL full-text search
- **refined_text**: Processed text optimized for search
- Fast keyword-based search with ranking

### 3. Structured Filtering
- **price**: Numeric filtering for price ranges
- **brand**: Brand-based filtering
- **gender**: Gender-specific products
- **tag1, tag2**: Category/feature tags for additional filtering

## üîå Supabase Connection

### Environment Configuration
```env
NEXT_PUBLIC_SUPABASE_URL=https://bndbyszujcbocpltxfah.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJuZGJ5c3p1amNib2NwbHR4ZmFoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjkxMTAxMTcsImV4cCI6MjA0NDY4NjExN30.jjpXVm1Iq5vtUlkI6c81w1-i1Rgb5Rv52E4_7V76tqM
```

### Connection Setup
```javascript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseKey)
```

## üìä Data Structure Examples

### Product Metadata Example
```json
{
  "product_id": "550e8400-e29b-41d4-a716-446655440000",
  "metadata": {
    "name": "iPhone 16 Pro Max",
    "description": "Latest iPhone with advanced camera system",
    "images": [
      "https://example.com/iphone16-1.jpg",
      "https://example.com/iphone16-2.jpg"
    ],
    "specifications": {
      "storage": "256GB",
      "color": "Natural Titanium",
      "display": "6.9-inch Super Retina XDR",
      "camera": "48MP Main + 12MP Ultra Wide + 12MP Telephoto"
    },
    "availability": {
      "in_stock": true,
      "quantity": 15
    },
    "store_info": {
      "store_id": "store_123",
      "store_name": "TechWorld",
      "location": "Ground Floor, Mall ABC"
    }
  }
}
```

### Product Search Example
```json
{
  "product_id": "550e8400-e29b-41d4-a716-446655440000",
  "text": "iPhone 16 Pro Max smartphone mobile phone",
  "price": 108999.00,
  "brand": "Apple",
  "gender": "unisex",
  "tag1": "smartphone",
  "tag2": "electronics",
  "refined_text": "iPhone 16 Pro Max Apple smartphone mobile phone latest advanced camera system",
  "embeddings": [0.1, 0.2, 0.3, ...] // Vector representation
}
```

## üîç Search Query Examples

### 1. Basic Product Search
```javascript
const searchProducts = async (query) => {
  const { data, error } = await supabase
    .from('product_search')
    .select('*')
    .textSearch('fts', query)
    .limit(20)
  
  return { data, error }
}
```

### 2. Price Range Filter
```javascript
const searchByPriceRange = async (minPrice, maxPrice) => {
  const { data, error } = await supabase
    .from('product_search')
    .select('*')
    .gte('price', minPrice)
    .lte('price', maxPrice)
    .order('price', { ascending: true })
  
  return { data, error }
}
```

### 3. Brand and Category Filter
```javascript
const searchByBrandAndCategory = async (brand, category) => {
  const { data, error } = await supabase
    .from('product_search')
    .select('*')
    .eq('brand', brand)
    .or(`tag1.eq.${category},tag2.eq.${category}`)
  
  return { data, error }
}
```

### 4. Combined Search with Metadata
```javascript
const searchWithMetadata = async (query) => {
  const { data, error } = await supabase
    .from('product_search')
    .select(`
      *,
      product_metadata!inner(metadata)
    `)
    .textSearch('fts', query)
    .limit(10)
  
  return { data, error }
}
```

## üöÄ Integration Workflow

### 1. Data Ingestion
```javascript
const insertProduct = async (productData) => {
  // Insert metadata
  const { data: metadataResult, error: metadataError } = await supabase
    .from('product_metadata')
    .insert({
      product_id: productData.id,
      metadata: productData.metadata
    })

  // Insert search data
  const { data: searchResult, error: searchError } = await supabase
    .from('product_search')
    .insert({
      product_id: productData.id,
      text: productData.searchText,
      price: productData.price,
      brand: productData.brand,
      gender: productData.gender,
      tag1: productData.category,
      tag2: productData.subcategory,
      refined_text: productData.refinedText,
      embeddings: productData.embeddings
    })

  return { metadataResult, searchResult, metadataError, searchError }
}
```

### 2. Search Implementation
```javascript
const performSearch = async (searchQuery, filters = {}) => {
  let query = supabase
    .from('product_search')
    .select(`
      product_id,
      text,
      price,
      brand,
      tag1,
      tag2,
      product_metadata!inner(metadata)
    `)

  // Apply text search
  if (searchQuery) {
    query = query.textSearch('fts', searchQuery)
  }

  // Apply filters
  if (filters.brand) {
    query = query.eq('brand', filters.brand)
  }
  
  if (filters.minPrice) {
    query = query.gte('price', filters.minPrice)
  }
  
  if (filters.maxPrice) {
    query = query.lte('price', filters.maxPrice)
  }

  if (filters.gender) {
    query = query.eq('gender', filters.gender)
  }

  const { data, error } = await query.limit(20)
  return { data, error }
}
```

## üìà Performance Optimization

### Indexes
- **GIN Index**: On `fts` column for fast full-text search
- **B-tree Indexes**: On frequently filtered columns (price, brand)
- **Vector Index**: For embedding similarity search (if using pgvector)

### Query Optimization
- Use `select()` to limit returned columns
- Implement pagination with `range()`
- Cache frequent searches
- Use connection pooling

## üîÑ Data Sync Strategy

### Real-time Updates
```javascript
// Subscribe to product changes
const subscription = supabase
  .channel('product_changes')
  .on('postgres_changes', 
    { 
      event: '*', 
      schema: 'public', 
      table: 'product_search' 
    }, 
    (payload) => {
      console.log('Product updated:', payload)
      // Update local state or cache
    }
  )
  .subscribe()
```

## üîÆ Next Steps

1. **Vector Search Setup**: Configure pgvector extension for semantic search
2. **Data Migration**: Import existing scraped data into the new schema
3. **Search API**: Build RESTful endpoints for product search
4. **Caching Layer**: Implement Redis for frequently searched products
5. **Analytics**: Track search patterns and popular products

## üìù Notes

- **Scraped Data**: Ready to integrate existing scraped product data
- **Second Endpoint**: Prepared for additional data source integration
- **Scalability**: Schema designed to handle large product catalogs
- **Flexibility**: JSONB metadata allows for diverse product types

---

**Status**: Ready for data integration and search implementation
**Next**: Awaiting second endpoint details for complete data source setup
